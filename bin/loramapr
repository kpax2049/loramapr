#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$ROOT_DIR"

COMPOSE=(docker compose)
COMPOSE_PROD=(docker compose -f docker-compose.prod.yml)

die() {
  echo "ERROR: $*" >&2
  exit 1
}

usage() {
  cat <<'EOF'
Usage:
  ./bin/loramapr up|down|logs|ps|reset|demo|keys|prod-up|prod-down|prod-logs|wait-ready|check

Commands:
  up      Start docker compose stack
  down    Stop docker compose stack
  logs    Tail docker compose logs
  ps      Show docker compose services
  reset   Stop stack and remove volumes (destructive)
  demo    Seed demo data if available
  keys    Generate QUERY/INGEST secrets in .env if missing
  prod-up    Start production compose stack
  prod-down  Stop production compose stack
  prod-logs  Tail production compose logs
  wait-ready Wait for API readiness endpoint to return HTTP 200
  check      Fast non-destructive local stack health check
EOF
}

read_env_value() {
  local key="$1"
  local default_value="$2"
  if [[ -f .env ]]; then
    local line
    line="$(grep -E "^${key}=" .env | tail -n 1 || true)"
    if [[ -n "$line" ]]; then
      echo "${line#*=}"
      return
    fi
  fi
  echo "$default_value"
}

require_compose() {
  command -v docker >/dev/null 2>&1 || die "docker is required"
  "${COMPOSE[@]}" version >/dev/null 2>&1 || die "docker compose (v2) is required"
}

require_curl() {
  command -v curl >/dev/null 2>&1 || die "curl is required"
}

ensure_env_file() {
  if [[ -f .env ]]; then
    return
  fi
  if [[ -f .env.example ]]; then
    cp .env.example .env
    echo "Created .env from .env.example"
  else
    touch .env
    echo "Created empty .env"
  fi
}

cmd_up() {
  require_compose
  ensure_env_file
  "${COMPOSE[@]}" up -d --build
  local api_port
  local frontend_port
  api_port="$(read_env_value API_PORT 3000)"
  frontend_port="$(read_env_value FRONTEND_PORT 5173)"
  echo ""
  echo "Stack is up."
  echo "Backend API:  http://localhost:${api_port}"
  echo "Health:       http://localhost:${api_port}/health"
  echo "Readiness:    http://localhost:${api_port}/readyz"
  echo "Frontend UI:  http://localhost:${frontend_port}"
}

cmd_down() {
  require_compose
  "${COMPOSE[@]}" down
}

cmd_logs() {
  require_compose
  "${COMPOSE[@]}" logs -f --tail=200
}

cmd_ps() {
  require_compose
  "${COMPOSE[@]}" ps
}

cmd_reset() {
  require_compose
  echo "Resetting stack (containers + volumes)..."
  "${COMPOSE[@]}" down -v
}

cmd_demo() {
  require_compose
  ensure_env_file

  if [[ -f scripts/seed-data.ts ]]; then
    "${COMPOSE[@]}" up -d --build postgres backend
    echo "Seeding demo data with scripts/seed-data.ts ..."
    "${COMPOSE[@]}" run --rm -e NODE_ENV=development backend npx ts-node scripts/seed-data.ts --db
    echo "Demo seed complete."
    return
  fi

  if [[ -f scripts/simulate-walk.ts ]]; then
    echo "Found scripts/simulate-walk.ts (requires an INGEST API key)."
    echo "Run: npm run simulate:walk -- --apiKey YOUR_KEY --deviceUid dev-1 --baseLat 37.77 --baseLon -122.43 --minutes 15 --intervalSec 5 --seed demo"
    return
  fi

  die "no demo/seed script found"
}

cmd_keys() {
  if [[ -x "$ROOT_DIR/scripts/setup/generate-secrets.sh" ]]; then
    "$ROOT_DIR/scripts/setup/generate-secrets.sh"
    return
  fi
  if [[ -f "$ROOT_DIR/scripts/setup/generate-secrets.js" ]]; then
    node "$ROOT_DIR/scripts/setup/generate-secrets.js"
    return
  fi
  die "missing scripts/setup/generate-secrets script"
}

cmd_prod_up() {
  require_compose
  ensure_env_file
  "${COMPOSE_PROD[@]}" up -d --build
}

cmd_prod_down() {
  require_compose
  "${COMPOSE_PROD[@]}" down
}

cmd_prod_logs() {
  require_compose
  "${COMPOSE_PROD[@]}" logs -f --tail=200
}

http_code() {
  local url="$1"
  local code
  code="$(curl -sS -o /dev/null -w "%{http_code}" --max-time 3 "$url" 2>/dev/null || true)"
  if [[ -z "$code" ]]; then
    echo "000"
    return
  fi
  echo "$code"
}

cmd_wait_ready() {
  require_curl
  ensure_env_file

  local api_port
  local base_url
  local timeout_seconds
  local start_ts
  local now
  local elapsed
  local code_api
  local code_root

  api_port="$(read_env_value API_PORT 3000)"
  base_url="http://localhost:${api_port}"
  timeout_seconds="${WAIT_READY_TIMEOUT_SECONDS:-90}"
  start_ts="$(date +%s)"

  while true; do
    code_api="$(http_code "${base_url}/api/readyz")"
    if [[ "$code_api" == "200" ]]; then
      echo "ready"
      return
    fi

    code_root="$(http_code "${base_url}/readyz")"
    if [[ "$code_root" == "200" ]]; then
      echo "ready"
      return
    fi

    now="$(date +%s)"
    elapsed="$((now - start_ts))"
    if (( elapsed >= timeout_seconds )); then
      die "timed out waiting for readiness after ${timeout_seconds}s (last /api/readyz=${code_api}, /readyz=${code_root})"
    fi

    sleep 2
  done
}

cmd_check() {
  require_compose
  require_curl
  ensure_env_file

  local api_port
  local base_url
  local health_path
  local ready_path
  local health_code
  local ready_code
  local devices_code
  local devices_summary

  api_port="$(read_env_value API_PORT 3000)"
  base_url="http://localhost:${api_port}"

  "${COMPOSE[@]}" up -d
  cmd_wait_ready

  health_path="/api/healthz"
  ready_path="/api/readyz"
  health_code="$(http_code "${base_url}${health_path}")"
  ready_code="$(http_code "${base_url}${ready_path}")"

  if [[ "$health_code" == "404" ]]; then
    health_path="/healthz"
    health_code="$(http_code "${base_url}${health_path}")"
  fi

  if [[ "$ready_code" == "404" ]]; then
    ready_path="/readyz"
    ready_code="$(http_code "${base_url}${ready_path}")"
  fi

  devices_code="$(http_code "${base_url}/api/devices")"
  case "$devices_code" in
    200) devices_summary="ok (200)" ;;
    401|403) devices_summary="auth-protected (${devices_code})" ;;
    *) devices_summary="unexpected (${devices_code})" ;;
  esac

  echo "check summary"
  echo "- ${health_path}: ${health_code}"
  echo "- ${ready_path}: ${ready_code}"
  echo "- /api/devices: ${devices_summary}"

  if [[ "$health_code" != "200" || "$ready_code" != "200" ]]; then
    die "health check failed"
  fi
}

main() {
  local cmd="${1:-help}"
  case "$cmd" in
    up) cmd_up ;;
    down) cmd_down ;;
    logs) cmd_logs ;;
    ps) cmd_ps ;;
    reset) cmd_reset ;;
    demo) cmd_demo ;;
    keys) cmd_keys ;;
    prod-up) cmd_prod_up ;;
    prod-down) cmd_prod_down ;;
    prod-logs) cmd_prod_logs ;;
    wait-ready) cmd_wait_ready ;;
    check) cmd_check ;;
    help|-h|--help) usage ;;
    *) usage; die "unknown command: $cmd" ;;
  esac
}

main "$@"
